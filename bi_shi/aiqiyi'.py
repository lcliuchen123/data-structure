
# 给定一个长度为N-1且只包含0和1的序列A1到AN-1，
# 如果一个1到N的排列P1到PN满足对于1≤i<N，
# 当Ai=0时Pi<Pi+1，当Ai=1时Pi>Pi+1，则称该排列符合要求，那么有多少个符合要求的排列？
# 第一行包含一个整数N，1<N≤1000。
# 第二行包含N-1个空格隔开的整数A1到AN-1，0≤Ai≤1
# 输出符合要求的排列个数对109+7取模后的结果。

# 有一个非常经典的概率问题，是一个袋子里面有若干个红球和若干个蓝球，
# 两个人轮流取出一个球，谁先取到红球谁就赢了，当人的先后顺序和球的数量确定时，
# 双方的胜率都可以由计算得到，这个问题显然是很简单的。
# 现在有一个进阶版的问题，同样是一个袋子里面有n个红球和m个蓝球，共有A，B，C三人参与游戏，
# 三人按照A，B，C的顺序轮流操作，在每一回合中，A，B，C都会随机从袋子里面拿走一个球，
# 然而真正分出胜负的只有A，B两个人，没错，C就是来捣乱的，他除了可以使得袋子里面减少一个球，没有其他任何意义，
# 而A，B谁 先拿到红球就可以获得胜利，但是由于C的存在，两人可能都拿不到红球，此时B获得胜利。

# 输入仅包含两个整数n和m,表示红球和蓝球的数量，中间用空格隔开。(0<=n,m<=1000)
# 请你输出A获胜的概率，结果保留5位小数。（四舍五入）

def get_vector(n,m):
    p = n/ (n+m)
    for i in range(2,n+m):
        m -= 1
        pb = m / (n+m)
        m -= 1
        pc = (n / (n+m)) * ((n-1) / (n+m-1)) + (m / (n+m))* (n / (n+m-1))
        pi = (1-p) * pb * pc
        p += pi

    return p

line = input()
n , m = [int(x) for x in line.split()]
p = get_vector(n,m)
print("%.4f" % p)